pile = {
	owner: {}, //only for reference
	cards: [
		{
			isFaceUp: true,
			identity: {value: 0, rank: 0, suit: 0}
		}
	]
}


round = {
	piles: [
		{ //discard pile
			owner: undefined,
			cards: [{}]
		}
	],
	hands: Map([
		[
			{} /*player reference*/,
			[{value: 0, rank: 0, suit: 0}]
		]
	])
}


CLIENT
event: 'cardMove',
from: {type: 'hand', index: 0},
to: {type: 'pile', index: 0, isFaceUp: true}


CLIENT
event: 'cardMove'
from: {type: 'deck'},
to: {type: 'hand'}






should clients be required to be up-to-date on previous events? 



CLIENT AT SEAT 0
event: 'cardMove',
order: 0, //if answer yes
data: {
	from: {type: 'deck'},
	to: {type: 'hand'}
}

//client at seat 0 still needs to know card, and all clients need to acknowledge message(?)
SERVER (to all)
event: 'cardMoved',
order: 0,
data: {
	from: {type: 'deck'}
	to: {type: 'hand', handSeat: 0}
}



better idea: have the server send out each event with its order. the client can keep track of the order of events by themselves. then, whenever the client receives an event, they can check if there's a gap between the last event and the one they just recieved. if there is, they can make a request to the server for the event corresponding to the missing order number.

SEAT 0
action: 'moveCard',
ackUID: 0,
from: {type: 'deck'},
to: {type: 'hand'}

//there needs to be something that tells the client which message of their's is being acknowledged.
//actually, maybe not. it seems WebSocket messages can't come out of order.
//https://stackoverflow.com/a/11809503 ,  https://stackoverflow.com/a/9283222
//but what happens if the acknowledgement message isn't received?
//also, do acknowledgements need an order? it might not otherwise be possible for the client to associate their action to the corresponding event. could it be possible for a different event to be sent after acknowledgement for an action but before its corresponding event?

//the order number has to be client dependent.
//what happens if this message drops? is it up to client to request missing event (as like 'better idea' section suggests)
SERVER (to SEAT 0)
event: 'ack',
ackUID: 0,
order: 0,
data: {
	wasSuccess: true, //necessary(?)
	cardIdentity: {value: 0, rank: 0, suit: 0},
	cardIndex: 7
}

SERVER (to all other seats)
event: 'cardMoved',
order: 0, //dependent on each seat. might not be 0 for, say, seat 2.
data: {
	from: {type: 'deck'},
	to: {type: 'hand'},
	by: 0 //earlier client's seat number
}

















[Host Upgrade Request] token=player_1token&business=hosting&maxSeats=5
Server seats player 1 at the newly created table.
Server - You have been seated. Here is the table.
{
	status: 'seated',
	table: {
		players: [
			{
				name: 'player 1',
				seat: 0
			}
		],
		host: 'player 1',
		maxSeats: 5,
		mode: 'lobby'
	}
}
[Lobby]


[Join Upgrade Request] token=player_2token&business=joining&tableID=0
Server seats player 2 at table 0.
Server - You have been seated. Here is the table.
...
[Lobby]



[Lobby]
Player 1 - I say, 'hello everyone!'
{
	event: 'chatMessage',
	message: 'hello everyone!'
}
Server - Everyone! Player 1 says, 'hello everyone!'
{
	event: 'chatMessage',
	author: 'Player 1',
	message: 'hello everyone!'
}
[Lobby]





Players are seated connections.


Table
{
 	players: [
 		{
 			conn: WebSocket,
 			name: String,
 			seat: Integer
 		}
 	],
 	host: { //should already be in players
 		conn: WebSocket,
 		name: String,
 		seat: Integer
 	},
 	allowMidgameJoining: Boolean,
 	maxSeats: Integer,
 	mode: String
}



Lobby classes have that state applied to them (before constructor application)
Lobby
{
	Event: 'chatMessage',
	Event: 'hostSignalsStart',
	Event: 'playerRequestsTable',

	table: Table
}




As EventEmitter:
-Adds a layer of abstraction between connection events and connection message sending (that layer being lobby events)
-The lobby event for players joining is a bit weird though, since it requires a call to the lobby's method (which tells us that players joining is an event that is somehow different from the other lobby events)
	-Players joining is different because it isn't connecting connection events with connection messages sending. It's connecting connection seating (which is an abstraction layer between the websocket http upgrade request and players joining (?) ) with connection message sending.




table (again, but different)
{
	playerInfo: [
		{
			player: Player,
			name: string,
			seat: integer
		}
	],
	host: playerInfo.Element, 	//not official term. also keep in mind that JSON serialization
	maxSeats: integer,			//doesn't keep referentiality
	mode: string
}









IMPORTANT:
SHOULD MAO BE CARD-COUNTABLE?
SHOULD THE GAME HAVE A FINITE DECK THAT GETS RESHUFFLED FROM THE DISCARD, OR, IN DEFENSE AGAINST CARD-COUNTING CLIENTS, SHOULD THE GAME HAVE AN INFINITE DECK?
 


play is the standard mode of Mao, where players are able to play cards, draw cards, and move cards around.
Play
Players can add cards into a pile with or without a written action.
Players can take cards from a pile with or without a written action.
Players can draw cards from the top of the deck with or without a written action.
Players can 'pass' by drawing the card on the top of the deck.
Players can choose any player (including themselves) to accuse. If they have chosen another player, the game goes from play to accusation. If the player has chosen themselves, they are automatically penalized.
Players can create a card group on the table (maybe with special permissions).
Players can delete a card group that they have created.


accusation is a bipartisan mode between the carder and the cardee (A.K.A. the accusing player and the accused player).
Accusation
The accused player can accept penalization, moving the game from accusation to play.
The accusing player can cancel their accusation without acknowledgement of fault, moving the game from accusation to retribution.
The accusing player can cancel their accusation with acknowledgement of fault, which penalizes the accusing player and moves the game from accusation to play.


retribution is a mode caused by the accusing player cancelling their accusation without acknowledgement of fault. during retribution, the accused player decides whether or not the accusing player should be penalized.
Retribution
The accused player can penalize the accusing player, moving the game from retribution to play.
The accused player can forgive the accusing player, moving the game from retribution to play.


rule-writing is a mode caused by a player not having any cards left in their hand and then not being carded for (maybe) three seconds after. during rule-writing, this player (who is called the winning player or maybe even Mao) chooses to create or remove a rule (although they cannot learn a rule through the process of removing it).
Rule-Writing
The winning player can write a new rule, moving the game from rule-writing to a new round of play.
The winning player can remove an old rule from a past round, moving the game from rule-writing to a new round of play.












!!!CARD MOVING!!!
This dialogue is always between seat 0 and server. The server is never talking to someone else in these examples. This also means that some of these messages (the ones the server sends without corresponding seat 0 action) wouldn't have client ack-uid attached to them.


SEAT 0 Draws Card (Actionless)
------------------------------
SEAT 0
from: {type: 'deck'},
to: {type: 'hand'}

SERVER
cardIdentity: {value: 0, rank: 0, suit: 0},
cardIndex: 7 //probably not necessary


SEAT 1 Draws Card (Actionless)
------------------------------
SERVER
from: {type: 'deck'},
to: {type: 'hand', length: 8},
by: 1


SEAT 0 Plays Card (Actionless)
------------------------------
SEAT 0
from: {type: 'hand', cardIndex: 6},
to: {type: 'pile', pileIndex: 0, cardIndex: 1, isFaceUp: true},

SERVER
(message sent, but this field is undefined)


SEAT 1 Plays Card (Actionless)
------------------------------
SERVER
cardIdentity: {value: 0, rank: 0, suit: 0},
from: {type: 'hand'},
to: {type: 'pile', pileIndex: 0, cardIndex: 1, isFaceUp: true},
by: 1


SEAT 0 Plays Card (With Action)
-------------------------------
SEAT 0
from: {type: 'hand', cardIndex: 6},
to: {type: 'pile', pileIndex: 0, cardIndex: 1, isFaceUp: true},
action: 'I say "ace of spades"'

SERVER
(message sent, but this field is undefined)


SEAT 1 Plays Card (With Action)
-------------------------------
SERVER
cardIdentity: {value: 39, rank: 0, suit: 3},
action: 'I say "ace of spades"'
from: {type: 'hand'},
to: {type: 'pile', pileIndex: 0, cardIndex: 1, isFaceUp: true},
by: 1


SEAT 0 Takes Unflipped Card From Discard (Actionless)
-----------------------------------------------------
SEAT 0
from: {type: 'pile', pileIndex: 0, cardIndex: 0},
to: {type: 'hand'}

SERVER
cardIndex: 7


SEAT 0 Takes Flipped Card From Discard (Actionless)
---------------------------------------------------
SEAT 0
from: {type: 'pile', pileIndex: 0, cardIndex: 1},
to: {type: 'hand'}

SERVER
cardIdentity: {value: 0, rank: 0, suit: 0},
cardIndex: 7


Seat 1 Takes Card From Discard (Actionless)
-------------------------------------------
SERVER
from: {type: 'pile', pileIndex: 0, cardIndex: 0},
to: {type: 'hand', length: 7},
by: 1




Types of Server Messages

Acknowledgement - Requires ack-uid and order
Event Notification - Requires order
State Response - Requires ack-uid


Types of Client Messages (always requires ack-uid. nature of the client message.)

Action
State Request


Game and chat ordering should be independent from one another.




Right now (August 14), I need to create card moving action listeners that keep track of order and forward event notifications to all other seats.



layers

onMessage
	onAction
	onStateReq



onMessage
{
	type: 'action',
	ackUID: 0,
	data: {
		type: 'moveCard',
		data: {
			from: {type: 'deck'},
			to: {type: 'hand'}
		}
	}
}


onAction
{
	type: 'moveCard',
	data: {
		from: {type: 'deck'},
		to: {type: 'hand'}
	}
}

won't continue if type 









chat

moving cards between hands, pile, and decks with an optional said action during play (e.g. "I say 'two of spades'")

accusing a different player during play

accepting an accusation and taking a penalty (as accused)

cancelling an accusation and taking a penalty (as accuser)

rule-writing after round

in-game round loop (new round > play ... > accusation > play ... > end round > rule writing > new round)




1-1: For each x there is a y, and for each y there is an x.
1-n: For each x there are some y's, and for each y there is an x.

Tables and rounds are 1-1s
Tables and player indexes are 1-ns
Tables and players are 1-ns
Players of a specific table and player indexes of the same table are 1-1s
Player indexes of a specific table and hands of the round of the same table are 1-1s
Action pools and 'table'-'player index' pairs are 1-1s
Player listeners and players are 1-1s
Player listeners and action pools are 1-1s


this is to help execute on actions. for now they will be maps, as that's all that's necessary, however, each relationship given can be modeled with a bi-map as well.
pretty sure actions in action pools know their round and playerIndex.


rounds = <tableIndex, round>
getRound(tableIndex) -> round

playerIndexes = <round, playerIndex[]>
getPlayerIndexes(round) -> playerIndex

actionPools = <(round, playerIndex), actionPool>
getActionPool(round, playerIndex) -> actionPool

playerConnections = <(round, playerIndex), playerConnection>
getPlayerConnection(round, playerIndex) -> playerConnection

playerListeners = <(round, playerIndex), playerListener>
getPlayerListener(round, playerIndex) -> playerListener



Y = card is shown to other players during moving
N = card is not shown to other players during moving
X = not a possible move combination

					  to
		      hand | pile | deck
		hand    X  |   Y  |  N
from	pile    Y  |   Y  |  Y
		deck    N  |   Y  |  X


//'by' property omitted for brevity
moveCard event format

hand-pile: {
	from: {source, length},
	to: {source, pileIndex, cardIndex},
	card: {value, rank, suit}
}

hand-deck: {
	from: {source, length},
	to: {source}
}

pile-hand: {
	from: {source, pileIndex, cardIndex},
	to: {source, length},
	card
}

pile-pile: {
	from: {source, pileIndex, cardIndex},
	to: {source, pileIndex, cardIndex},
	card
}

pile-deck: {
	from: {source, pileIndex, cardIndex},
	to: {source},
	card
}

deck-hand: {
	from: {source},
	to: {source, length}
}

deck-pile: {
	from: {source},
	to: {source, pileIndex, cardIndex},
	card
}




accusation: {
	accuser: playerIndex,
	accused: playerIndex,
	start: Date
}



should accusation need a reason? on the one hand, it's useful historically; if a player is looking back on game events, they can rediscover the reasons behind an accusation. it also helps keeps things clear between players by not allowing space for assumptions as to the reason: everyone is directly made aware of the accuser's reasoning. on the other hand, it makes things slower in the cases where the accused KNOWS why they're being accused, but still has to wait for the accuser to fill out their form before they can accept.






should an action whose performability differ depending on the state be split into different actions or kept as one? action pool manipulation has been the top-level determiner of an action's performability in the past.

accuse's performability never differs on state alone, though. during lastChance, accuse's performability is still partly determined by its arguments. this might not be a problem at all.

an action that can't be performed because of the state vs an action that can't be performed because of the state and its arguments.





//do not add player action pools here. you'll only be repeating the same mistakes. remember, actions themselves check the state to see whether or not and how they should perform.
table: {
	playerConnections,
	mode*,
	chatLog,
	game
}

playerConnections: <playerID*, WebSocket>

chatLog: chat[]
chat: {
	quote: string,
	by: playerID*,
	timestamp: number
}



game: {
	round,
	rules,
	eventHistories,
	inBetweenRounds: boolean,
	lastWinner: playerID*
}


round: { hands, piles, seating, mode*, winningSeat: seat*, accusation } //different mode from table
hands: <seat*, card[]>
piles: pile[]
pile: { owner: seat*, cards: card[] }
seating: <playerID*, seat*> (modeled as array, with playerIDs as elements, and seats as indexes)
accusation: {
	accused: seat*,
	accuser: seat*,
}


//index of a rule in roundRules corresponds to the round it was written after.
rules: { starterRules: string[], roundRules: string[] }

eventHistories: <playerID*, eventHistory>
eventHistory: messages[]


actionPools: <playerID*, actionPools>
actionPool: <actionName*, action> (modeled as an object, as actionName is represented by string)
action: Function(data: Any)






need a way into a table. probably http upgrade request. that should allow clients to host and join tables. there should also be a way to browse tables so that clients can be informed enough to join a table using the http upgrade request.