pile = {
	owner: {}, //only for reference
	cards: [
		{
			isFaceUp: true,
			identity: {value: 0, rank: 0, suit: 0}
		}
	]
}


round = {
	piles: [
		{ //discard pile
			owner: undefined,
			cards: [{}]
		}
	],
	hands: Map([
		[
			{} /*player reference*/,
			[{value: 0, rank: 0, suit: 0}]
		]
	])
}


CLIENT
event: 'cardMove',
from: {type: 'hand', index: 0},
to: {type: 'pile', index: 0, isFaceUp: true}


CLIENT
event: 'cardMove'
from: {type: 'deck'},
to: {type: 'hand'}






should clients be required to be up-to-date on previous events? 



CLIENT AT SEAT 0
event: 'cardMove',
order: 0, //if answer yes
data: {
	from: {type: 'deck'},
	to: {type: 'hand'}
}

//client at seat 0 still needs to know card, and all clients need to acknowledge message(?)
SERVER (to all)
event: 'cardMoved',
order: 0,
data: {
	from: {type: 'deck'}
	to: {type: 'hand', handSeat: 0}
}



better idea: have the server send out each event with its order. the client can keep track of the order of events by themselves. then, whenever the client receives an event, they can check if there's a gap between the last event and the one they just recieved. if there is, they can make a request to the server for the event corresponding to the missing order number.

SEAT 0
action: 'moveCard',
ackUUID: string,
from: {type: 'deck'},
to: {type: 'hand'}

//there needs to be something that tells the client which message of their's is being acknowledged.
//actually, maybe not. it seems WebSocket messages can't come out of order.
//https://stackoverflow.com/a/11809503 ,  https://stackoverflow.com/a/9283222
//but what happens if the acknowledgement message isn't received?
//also, do acknowledgements need an order? it might not otherwise be possible for the client to associate their action to the corresponding event. could it be possible for a different event to be sent after acknowledgement for an action but before its corresponding event?

//the order number has to be client dependent.
//what happens if this message drops? is it up to client to request missing event (as like 'better idea' section suggests)
SERVER (to SEAT 0)
event: 'ack',
ackUUID: string,
order: 0,
data: {
	wasSuccess: true, //necessary(?)
	cardIdentity: {value: 0, rank: 0, suit: 0},
	cardIndex: 7
}

SERVER (to all other seats)
event: 'cardMoved',
order: 0, //dependent on each seat. might not be 0 for, say, seat 2.
data: {
	from: {type: 'deck'},
	to: {type: 'hand'},
	by: 0 //earlier client's seat number
}

















[Host Upgrade Request] token=player_1token&business=hosting&maxSeats=5
Server seats player 1 at the newly created table.
Server - You have been seated. Here is the table.
{
	status: 'seated',
	table: {
		players: [
			{
				name: 'player 1',
				seat: 0
			}
		],
		host: 'player 1',
		maxSeats: 5,
		mode: 'lobby'
	}
}
[Lobby]


[Join Upgrade Request] token=player_2token&business=joining&tableID=0
Server seats player 2 at table 0.
Server - You have been seated. Here is the table.
...
[Lobby]



[Lobby]
Player 1 - I say, 'hello everyone!'
{
	event: 'chatMessage',
	message: 'hello everyone!'
}
Server - Everyone! Player 1 says, 'hello everyone!'
{
	event: 'chatMessage',
	author: 'Player 1',
	message: 'hello everyone!'
}
[Lobby]





Players are seated connections.


Table
{
 	players: [
 		{
 			conn: WebSocket,
 			name: String,
 			seat: Integer
 		}
 	],
 	host: { //should already be in players
 		conn: WebSocket,
 		name: String,
 		seat: Integer
 	},
 	allowMidgameJoining: Boolean,
 	maxSeats: Integer,
 	mode: String
}



Lobby classes have that state applied to them (before constructor application)
Lobby
{
	Event: 'chatMessage',
	Event: 'hostSignalsStart',
	Event: 'playerRequestsTable',

	table: Table
}




As EventEmitter:
-Adds a layer of abstraction between connection events and connection message sending (that layer being lobby events)
-The lobby event for players joining is a bit weird though, since it requires a call to the lobby's method (which tells us that players joining is an event that is somehow different from the other lobby events)
	-Players joining is different because it isn't connecting connection events with connection messages sending. It's connecting connection seating (which is an abstraction layer between the websocket http upgrade request and players joining (?) ) with connection message sending.




table (again, but different)
{
	playerInfo: [
		{
			player: Player,
			name: string,
			seat: integer
		}
	],
	host: playerInfo.Element, 	//not official term. also keep in mind that JSON serialization
	maxSeats: integer,			//doesn't keep referentiality
	mode: string
}









IMPORTANT:
SHOULD MAO BE CARD-COUNTABLE?
SHOULD THE GAME HAVE A FINITE DECK THAT GETS RESHUFFLED FROM THE DISCARD, OR, IN DEFENSE AGAINST CARD-COUNTING CLIENTS, SHOULD THE GAME HAVE AN INFINITE DECK?
 


play is the standard mode of Mao, where players are able to play cards, draw cards, and move cards around.
Play
Players can add cards into a pile with or without a written action.
Players can take cards from a pile with or without a written action.
Players can draw cards from the top of the deck with or without a written action.
Players can 'pass' by drawing the card on the top of the deck.
Players can choose any player (including themselves) to accuse. If they have chosen another player, the game goes from play to accusation. If the player has chosen themselves, they are automatically penalized.
Players can create a card group on the table (maybe with special permissions).
Players can delete a card group that they have created.


accusation is a bipartisan mode between the carder and the cardee (A.K.A. the accusing player and the accused player).
Accusation
The accused player can accept penalization, moving the game from accusation to play.
The accusing player can cancel their accusation without acknowledgement of fault, moving the game from accusation to retribution.
The accusing player can cancel their accusation with acknowledgement of fault, which penalizes the accusing player and moves the game from accusation to play.


retribution is a mode caused by the accusing player cancelling their accusation without acknowledgement of fault. during retribution, the accused player decides whether or not the accusing player should be penalized.
Retribution
The accused player can penalize the accusing player, moving the game from retribution to play.
The accused player can forgive the accusing player, moving the game from retribution to play.


rule-writing is a mode caused by a player not having any cards left in their hand and then not being carded for (maybe) three seconds after. during rule-writing, this player (who is called the winning player or maybe even Mao) chooses to create or remove a rule (although they cannot learn a rule through the process of removing it).
Rule-Writing
The winning player can write a new rule, moving the game from rule-writing to a new round of play.
The winning player can remove an old rule from a past round, moving the game from rule-writing to a new round of play.












!!!CARD MOVING!!!
This dialogue is always between seat 0 and server. The server is never talking to someone else in these examples. This also means that some of these messages (the ones the server sends without corresponding seat 0 action) wouldn't have client ack-uuid attached to them.


SEAT 0 Draws Card
-----------------
SEAT 0
from: {type: 'deck'},
to: {type: 'hand'}

SERVER
cardIdentity: {value: 0, rank: 0, suit: 0},
cardIndex: 7 //probably not necessary


SEAT 1 Draws Card
-----------------
SERVER
from: {type: 'deck'},
to: {type: 'hand'},
by: 1


SEAT 0 Plays Card (Actionless)
------------------------------
SEAT 0
from: {type: 'hand', cardIndex: 6},
to: {type: 'pile', pileIndex: 0, cardIndex: 1, isFaceUp: true},

SERVER
(message sent, but this field is undefined)


SEAT 1 Plays Card (Actionless)
------------------------------
SERVER
cardIdentity: {value: 0, rank: 0, suit: 0},
from: {type: 'hand'},
to: {type: 'pile', pileIndex: 0, cardIndex: 1, isFaceUp: true},
by: 1


SEAT 0 Plays Card (With Action)
-------------------------------
SEAT 0
from: {type: 'hand', cardIndex: 6},
to: {type: 'pile', pileIndex: 0, cardIndex: 1, isFaceUp: true},
action: 'I say "ace of spades"'

SERVER
(message sent, but this field is undefined)


SEAT 1 Plays Card (With Action)
-------------------------------
SERVER
cardIdentity: {value: 39, rank: 0, suit: 3},
action: 'I say "ace of spades"'
from: {type: 'hand'},
to: {type: 'pile', pileIndex: 0, cardIndex: 1, isFaceUp: true},
by: 1


SEAT 0 Takes Unflipped Card From Discard (Actionless)
-----------------------------------------------------
SEAT 0
from: {type: 'pile', pileIndex: 0, cardIndex: 0},
to: {type: 'hand'}

SERVER
cardIndex: 7


SEAT 0 Takes Flipped Card From Discard (Actionless)
---------------------------------------------------
SEAT 0
from: {type: 'pile', pileIndex: 0, cardIndex: 1},
to: {type: 'hand'}

SERVER
cardIdentity: {value: 0, rank: 0, suit: 0},
cardIndex: 7


Seat 1 Takes Card From Discard (Actionless)
-------------------------------------------
SERVER
from: {type: 'pile', pileIndex: 0, cardIndex: 0},
to: {type: 'hand'},
by: 1